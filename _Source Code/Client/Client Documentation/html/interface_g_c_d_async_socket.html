<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mobile Clinic: GCDAsyncSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="clinicLogo.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mobile Clinic
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Senior Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">GCDAsyncSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for GCDAsyncSocket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_socket__inherit__graph.png" border="0" usemap="#_g_c_d_async_socket_inherit__map" alt="Inheritance graph"/></div>
<map name="_g_c_d_async_socket_inherit__map" id="_g_c_d_async_socket_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for GCDAsyncSocket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_socket__coll__graph.png" border="0" usemap="#_g_c_d_async_socket_coll__map" alt="Collaboration graph"/></div>
<map name="_g_c_d_async_socket_coll__map" id="_g_c_d_async_socket_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4213bb26f5207ee3f402fe463badc691"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4213bb26f5207ee3f402fe463badc691">init</a></td></tr>
<tr class="memitem:aaa7a544e6a86f4df110ff353e4a10597"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa7a544e6a86f4df110ff353e4a10597"></a>
(id)&#160;</td><td class="memItemRight" valign="bottom">- <b>initWithSocketQueue:</b></td></tr>
<tr class="memitem:a504b2a0981de8ea8758effb60245973e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a504b2a0981de8ea8758effb60245973e"></a>
(id)&#160;</td><td class="memItemRight" valign="bottom">- <b>initWithDelegate:delegateQueue:</b></td></tr>
<tr class="memitem:a75fe279d42a5c8078f8bac4d953c81a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75fe279d42a5c8078f8bac4d953c81a8"></a>
(id)&#160;</td><td class="memItemRight" valign="bottom">- <b>initWithDelegate:delegateQueue:socketQueue:</b></td></tr>
<tr class="memitem:a6c98e239b6ba279cfc95c64db9de555c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c98e239b6ba279cfc95c64db9de555c"></a>
(id)&#160;</td><td class="memItemRight" valign="bottom">- <b>delegate</b></td></tr>
<tr class="memitem:a5147f10c2f5e0df2682c4ce073138ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5147f10c2f5e0df2682c4ce073138ac8"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setDelegate:</b></td></tr>
<tr class="memitem:aa5625ed5c76085530b96dc6c5e2839d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5625ed5c76085530b96dc6c5e2839d1"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>synchronouslySetDelegate:</b></td></tr>
<tr class="memitem:ad8e601f3e3e4ec791f9a7741ff12aec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e601f3e3e4ec791f9a7741ff12aec5"></a>
(dispatch_queue_t)&#160;</td><td class="memItemRight" valign="bottom">- <b>delegateQueue</b></td></tr>
<tr class="memitem:ad2a40c88499dd4d26e1ee23e51619dd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a40c88499dd4d26e1ee23e51619dd2"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setDelegateQueue:</b></td></tr>
<tr class="memitem:ababced98cdedb94928d4e96b86005f8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ababced98cdedb94928d4e96b86005f8f"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>synchronouslySetDelegateQueue:</b></td></tr>
<tr class="memitem:ac861d6b5813a114fba01d00fecbeb36f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac861d6b5813a114fba01d00fecbeb36f"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>getDelegate:delegateQueue:</b></td></tr>
<tr class="memitem:a7e25f164690499ebb02ad52944ebd4f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e25f164690499ebb02ad52944ebd4f5"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setDelegate:delegateQueue:</b></td></tr>
<tr class="memitem:a16ada359e981e7021f834a467cd47558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16ada359e981e7021f834a467cd47558"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>synchronouslySetDelegate:delegateQueue:</b></td></tr>
<tr class="memitem:a9fd367a3576e58665df01f6a376621eb"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9fd367a3576e58665df01f6a376621eb">isIPv4Enabled</a></td></tr>
<tr class="memitem:a5a64cbec31543316e5318fb1a5caf393"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a64cbec31543316e5318fb1a5caf393"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setIPv4Enabled:</b></td></tr>
<tr class="memitem:a86e92e8be0617f9ec2ae403d5ff3a04e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e92e8be0617f9ec2ae403d5ff3a04e"></a>
(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <b>isIPv6Enabled</b></td></tr>
<tr class="memitem:a41d137c83f5004f0fb38422b15270d7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d137c83f5004f0fb38422b15270d7d"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setIPv6Enabled:</b></td></tr>
<tr class="memitem:ac8a98d880cd216a59a118b9243f9896d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8a98d880cd216a59a118b9243f9896d"></a>
(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <b>isIPv4PreferredOverIPv6</b></td></tr>
<tr class="memitem:a73908d258ad70bf185c3ba61fd0a80ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73908d258ad70bf185c3ba61fd0a80ab"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setPreferIPv4OverIPv6:</b></td></tr>
<tr class="memitem:ab46069d6ffbcb6a0bb1eae5aaaafe94a"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab46069d6ffbcb6a0bb1eae5aaaafe94a">userData</a></td></tr>
<tr class="memitem:ad64373d841eb1408af17341cf27067f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad64373d841eb1408af17341cf27067f4"></a>
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>setUserData:</b></td></tr>
<tr class="memitem:afdd8b0c1d2b3c9dd5aa86d17a67f59cd"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#afdd8b0c1d2b3c9dd5aa86d17a67f59cd">acceptOnPort:error:</a></td></tr>
<tr class="memitem:af1c9bdfc157bbfa839a84b48be2ac8d6"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#af1c9bdfc157bbfa839a84b48be2ac8d6">acceptOnInterface:port:error:</a></td></tr>
<tr class="memitem:a84fdf1fb2c17119b3bb0bc859122179f"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a84fdf1fb2c17119b3bb0bc859122179f">connectToHost:onPort:error:</a></td></tr>
<tr class="memitem:a212c9a2d54b4526ee13b7527fc670696"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a212c9a2d54b4526ee13b7527fc670696">connectToHost:onPort:withTimeout:error:</a></td></tr>
<tr class="memitem:ac9f8046ea1132086a24377304fb4c17e"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac9f8046ea1132086a24377304fb4c17e">connectToHost:onPort:viaInterface:withTimeout:error:</a></td></tr>
<tr class="memitem:a2e1af5ef7a3e1ee37613dddb7c0e0617"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2e1af5ef7a3e1ee37613dddb7c0e0617">connectToAddress:error:</a></td></tr>
<tr class="memitem:ae023e135c607e4ad8a7dd86a1be7efe2"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae023e135c607e4ad8a7dd86a1be7efe2">connectToAddress:withTimeout:error:</a></td></tr>
<tr class="memitem:a12de200ef677c49f7b013b1646453dcb"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a12de200ef677c49f7b013b1646453dcb">connectToAddress:viaInterface:withTimeout:error:</a></td></tr>
<tr class="memitem:a960705de531a20389fb29928d43258c3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a960705de531a20389fb29928d43258c3">disconnect</a></td></tr>
<tr class="memitem:a9c49760a3286a595f3cdc0702733baed"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9c49760a3286a595f3cdc0702733baed">disconnectAfterReading</a></td></tr>
<tr class="memitem:a40c9570c2e696d6c48347024fa1f8b5c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a40c9570c2e696d6c48347024fa1f8b5c">disconnectAfterWriting</a></td></tr>
<tr class="memitem:a31e39568995cdc85c4feb5a76c645d5f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a31e39568995cdc85c4feb5a76c645d5f">disconnectAfterReadingAndWriting</a></td></tr>
<tr class="memitem:a72a57ce3f39762161947846bbe03a621"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a72a57ce3f39762161947846bbe03a621">isDisconnected</a></td></tr>
<tr class="memitem:ad3515f7fe2b8ed2b9e14233cf7ede0bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3515f7fe2b8ed2b9e14233cf7ede0bc"></a>
(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <b>isConnected</b></td></tr>
<tr class="memitem:a918b8d6a97c1f0a2cd938cc61d3ff353"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a918b8d6a97c1f0a2cd938cc61d3ff353">connectedHost</a></td></tr>
<tr class="memitem:abd1230002ad97ab26f9bd7d77e5139c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd1230002ad97ab26f9bd7d77e5139c1"></a>
(uint16_t)&#160;</td><td class="memItemRight" valign="bottom">- <b>connectedPort</b></td></tr>
<tr class="memitem:a544fa124053aea063a8be148cf24d491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a544fa124053aea063a8be148cf24d491"></a>
(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <b>localHost</b></td></tr>
<tr class="memitem:af00dc543ea2d9f9005e1c36ac8c71210"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af00dc543ea2d9f9005e1c36ac8c71210"></a>
(uint16_t)&#160;</td><td class="memItemRight" valign="bottom">- <b>localPort</b></td></tr>
<tr class="memitem:aa9aa24b40191e606b428588285deb640"><td class="memItemLeft" align="right" valign="top">(NSData *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa9aa24b40191e606b428588285deb640">connectedAddress</a></td></tr>
<tr class="memitem:a279be33392f836041828ae18ed4678a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a279be33392f836041828ae18ed4678a3"></a>
(NSData *)&#160;</td><td class="memItemRight" valign="bottom">- <b>localAddress</b></td></tr>
<tr class="memitem:a7f1734034c9aa5b62cfeb69f203729e3"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7f1734034c9aa5b62cfeb69f203729e3">isIPv4</a></td></tr>
<tr class="memitem:aa009ac699bce64f1d087a0eafeb2a371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa009ac699bce64f1d087a0eafeb2a371"></a>
(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <b>isIPv6</b></td></tr>
<tr class="memitem:ac03a5b3ccb5aee5f881792926571db0a"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac03a5b3ccb5aee5f881792926571db0a">isSecure</a></td></tr>
<tr class="memitem:a58e63ca19338d5e052ad36e2e64ec585"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a58e63ca19338d5e052ad36e2e64ec585">readDataWithTimeout:tag:</a></td></tr>
<tr class="memitem:a289b8c694675c219c9726385c90e8068"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a289b8c694675c219c9726385c90e8068">readDataWithTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr class="memitem:a9ec74c83f6f87dfd8980c98deae38640"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9ec74c83f6f87dfd8980c98deae38640">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></td></tr>
<tr class="memitem:a2acf5d5f2c006ea0e14a97b8802bdf7d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2acf5d5f2c006ea0e14a97b8802bdf7d">readDataToLength:withTimeout:tag:</a></td></tr>
<tr class="memitem:a7f742375bde66d11c43a478835c04805"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7f742375bde66d11c43a478835c04805">readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr class="memitem:a3a92e46de7766b3ac649f3d68d370599"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a3a92e46de7766b3ac649f3d68d370599">readDataToData:withTimeout:tag:</a></td></tr>
<tr class="memitem:a8782b6bf0862529a8efad865b20eb55f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a8782b6bf0862529a8efad865b20eb55f">readDataToData:withTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr class="memitem:abfb0d880d5853402309d80151c19ef85"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abfb0d880d5853402309d80151c19ef85">readDataToData:withTimeout:maxLength:tag:</a></td></tr>
<tr class="memitem:a2a8c215b2b1baee60b831081a5e302ac"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2a8c215b2b1baee60b831081a5e302ac">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></td></tr>
<tr class="memitem:afdb958711cc3c0089b4a89f7dfed45a9"><td class="memItemLeft" align="right" valign="top">(float)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#afdb958711cc3c0089b4a89f7dfed45a9">progressOfReadReturningTag:bytesDone:total:</a></td></tr>
<tr class="memitem:a7f85c2e3c19bbe013c180b4668a28fc2"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7f85c2e3c19bbe013c180b4668a28fc2">writeData:withTimeout:tag:</a></td></tr>
<tr class="memitem:a5c5daeaa738324a501b418d7cc283a35"><td class="memItemLeft" align="right" valign="top">(float)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5c5daeaa738324a501b418d7cc283a35">progressOfWriteReturningTag:bytesDone:total:</a></td></tr>
<tr class="memitem:aec4d670add3f78c669277990d7b48056"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aec4d670add3f78c669277990d7b48056">startTLS:</a></td></tr>
<tr class="memitem:ad6699479eef6e61e54c6edfcb17a75ed"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad6699479eef6e61e54c6edfcb17a75ed">autoDisconnectOnClosedReadStream</a></td></tr>
<tr class="memitem:adc2fecde2f4d460a7e8d010d9cf01300"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#adc2fecde2f4d460a7e8d010d9cf01300">setAutoDisconnectOnClosedReadStream:</a></td></tr>
<tr class="memitem:a839e97a5f8fe5f01900dcb41259a535c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a839e97a5f8fe5f01900dcb41259a535c">markSocketQueueTargetQueue:</a></td></tr>
<tr class="memitem:a76712c0f929cd79210da79ba74e7d1f9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a76712c0f929cd79210da79ba74e7d1f9">unmarkSocketQueueTargetQueue:</a></td></tr>
<tr class="memitem:a0f9e5a401b98234ed1522174f1ef5d33"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a0f9e5a401b98234ed1522174f1ef5d33">performBlock:</a></td></tr>
<tr class="memitem:ad7cd01612683e0994e7ef2fadf77952e"><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad7cd01612683e0994e7ef2fadf77952e">socketFD</a></td></tr>
<tr class="memitem:a2b9c119ffa6ff18321572f26a759b9ed"><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a></td></tr>
<tr class="memitem:ad6120d297c599aff1e50bd2ce917e3ad"><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a></td></tr>
<tr class="memitem:a09f53a1bc824259a55ff249183111beb"><td class="memItemLeft" align="right" valign="top">(SSLContextRef)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a09f53a1bc824259a55ff249183111beb">sslContext</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad25cbed4327e1a30c369f5367af185f0"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#ad25cbed4327e1a30c369f5367af185f0">hostFromAddress:</a></td></tr>
<tr class="memitem:af4f629d88d3cb05f4bfbcc5612ad409b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4f629d88d3cb05f4bfbcc5612ad409b"></a>
(uint16_t)&#160;</td><td class="memItemRight" valign="bottom">+ <b>portFromAddress:</b></td></tr>
<tr class="memitem:af93259047e3fb74d1ae5a7c37f713821"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af93259047e3fb74d1ae5a7c37f713821"></a>
(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <b>getHost:port:fromAddress:</b></td></tr>
<tr class="memitem:a6d7dfcd7967c0e16b86ae64e5579b709"><td class="memItemLeft" align="right" valign="top">(NSData *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a6d7dfcd7967c0e16b86ae64e5579b709">CRLFData</a></td></tr>
<tr class="memitem:adde78bb75988b51f5c403daebcd91f99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adde78bb75988b51f5c403daebcd91f99"></a>
(NSData *)&#160;</td><td class="memItemRight" valign="bottom">+ <b>CRData</b></td></tr>
<tr class="memitem:a9f80c130183f3fa0f324c7505127ab77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f80c130183f3fa0f324c7505127ab77"></a>
(NSData *)&#160;</td><td class="memItemRight" valign="bottom">+ <b>LFData</b></td></tr>
<tr class="memitem:aa051f54bdd6c087a6b4a51c799dbc68b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa051f54bdd6c087a6b4a51c799dbc68b"></a>
(NSData *)&#160;</td><td class="memItemRight" valign="bottom">+ <b>ZeroData</b></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af1c9bdfc157bbfa839a84b48be2ac8d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) acceptOnInterface: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(uint16_t)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as acceptOnPort:error: with the additional option of specifying which interface to listen on.</p>
<p>For example, you could specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.</p>
<p>The interface may be specified by name (e.g. "en1" or "lo0") or by IP address (e.g. "192.168.4.34"). You may also use the special strings "localhost" or "loopback" to specify that the socket only accept connections from the local machine.</p>
<p>You can see the list of interfaces via the command line utility "ifconfig", or programmatically via the getifaddrs() function.</p>
<p>To accept connections on any interface pass nil, or simply use the acceptOnPort:error: method. </p>

</div>
</div>
<a class="anchor" id="afdd8b0c1d2b3c9dd5aa86d17a67f59cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) acceptOnPort: </td>
          <td></td>
          <td class="paramtype">(uint16_t)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the socket to begin listening and accepting connections on the given port. When a connection is accepted, a new instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will be spawned to handle it, and the socket:didAcceptNewSocket: delegate method will be invoked.</p>
<p>The socket will listen on all available interfaces (e.g. wifi, ethernet, etc) </p>

</div>
</div>
<a class="anchor" id="ad6699479eef6e61e54c6edfcb17a75ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) autoDisconnectOnClosedReadStream </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traditionally sockets are not closed until the conversation is over. However, it is technically possible for the remote enpoint to close its write stream. Our socket would then be notified that there is no more data to be read, but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>
<p>The argument for this confusing functionality stems from the idea that a client could shut down its write stream after sending a request to the server, thus notifying the server there are to be no further requests. In practice, however, this technique did little to help server developers.</p>
<p>To make matters worse, from a TCP perspective there is no way to tell the difference from a read stream close and a full socket close. They both result in the TCP stack receiving a FIN packet. The only way to tell is by continuing to write to the socket. If it was only a read stream close, then writes will continue to work. Otherwise an error will be occur shortly (when the remote end sends us a RST packet).</p>
<p>In addition to the technical challenges and confusion, many high level socket/stream API's provide no support for dealing with the problem. If the read stream is closed, the API immediately declares the socket to be closed, and shuts down the write stream as well. In fact, this is what Apple's CFStream API does. It might sound like poor design at first, but in fact it simplifies development.</p>
<p>The vast majority of the time if the read stream is closed it's because the remote endpoint closed its socket. Thus it actually makes sense to close the socket at this point. And in fact this is what most networking developers want and expect to happen. However, if you are writing a server that interacts with a plethora of clients, you might encounter a client that uses the discouraged technique of shutting down its write stream. If this is the case, you can set this property to NO, and make use of the socketDidCloseReadStream delegate method.</p>
<p>The default value is YES.</p>
<p>See header file for big discussion of this method. </p>

</div>
</div>
<a class="anchor" id="aa9aa24b40191e606b428588285deb640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSData *) connectedAddress </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the local or remote address to which this socket is connected, specified as a sockaddr structure wrapped in a NSData object.</p>
<p>See also the connectedHost, connectedPort, localHost and localPort methods. </p>

</div>
</div>
<a class="anchor" id="a918b8d6a97c1f0a2cd938cc61d3ff353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_string.html">NSString</a> *) connectedHost </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected. The host will be an IP address. </p>

</div>
</div>
<a class="anchor" id="a2e1af5ef7a3e1ee37613dddb7c0e0617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object. For example, a NSData object returned from NSNetService's addresses method.</p>
<p>If you have an existing struct sockaddr you can convert it to a NSData object like so: struct sockaddr sa -&gt; NSData *dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len]; struct sockaddr *sa -&gt; NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr-&gt;sa_len];</p>
<p>This method invokes connectToAdd </p>

</div>
</div>
<a class="anchor" id="a12de200ef677c49f7b013b1646453dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">viaInterface:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to the given address, using the specified interface and timeout.</p>
<p>The address is specified as a sockaddr structure wrapped in a NSData object. For example, a NSData object returned from NSNetService's addresses method.</p>
<p>If you have an existing struct sockaddr you can convert it to a NSData object like so: struct sockaddr sa -&gt; NSData *dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len]; struct sockaddr *sa -&gt; NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr-&gt;sa_len];</p>
<p>The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35"). The interface may also be used to specify the local port (see below).</p>
<p>The timeout is optional. To not time out use a negative time interval.</p>
<p>This method will return NO if an error is detected, and set the error pointer (if one was given). Possible errors would be a nil host, invalid interface, or socket is already connected.</p>
<p>If no errors are detected, this method will start a background connect operation and immediately return YES. The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>
<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing. All read/write operations will be queued, and upon socket connection, the operations will be dequeued and processed in order.</p>
<p>The interface may optionally contain a port number at the end of the string, separated by a colon. This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end) To specify both interface and local port: "en1:8082" or "192.168.4.35:2424". To specify only local port: ":8082". Please note this is an advanced feature, and is somewhat hidden on purpose. You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection. If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere. Local ports do NOT need to match remote ports. In fact, they almost never do. This feature is here for networking professionals using very advanced techniques. </p>

</div>
</div>
<a class="anchor" id="ae023e135c607e4ad8a7dd86a1be7efe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as connectToAddress:error: with an additional timeout option. To not time out use a negative time interval, or simply use the connectToAddress:error: method. </p>

</div>
</div>
<a class="anchor" id="a84fdf1fb2c17119b3bb0bc859122179f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(uint16_t)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to the given host and port.</p>
<p>This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface, and no timeout. </p>

</div>
</div>
<a class="anchor" id="ac9f8046ea1132086a24377304fb4c17e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(uint16_t)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">viaInterface:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>
<p>The host may be a domain name (e.g. "deusty.com") or an IP address string (e.g. "192.168.0.2"). The host may also be the special strings "localhost" or "loopback" to specify connecting to a service on the local machine.</p>
<p>The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35"). The interface may also be used to specify the local port (see below).</p>
<p>To not time out use a negative time interval.</p>
<p>This method will return NO if an error is detected, and set the error pointer (if one was given). Possible errors would be a nil host, invalid interface, or socket is already connected.</p>
<p>If no errors are detected, this method will start a background connect operation and immediately return YES. The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>
<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing. All read/write operations will be queued, and upon socket connection, the operations will be dequeued and processed in order.</p>
<p>The interface may optionally contain a port number at the end of the string, separated by a colon. This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end) To specify both interface and local port: "en1:8082" or "192.168.4.35:2424". To specify only local port: ":8082". Please note this is an advanced feature, and is somewhat hidden on purpose. You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection. If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere. Local ports do NOT need to match remote ports. In fact, they almost never do. This feature is here for networking professionals using very advanced techniques. </p>

</div>
</div>
<a class="anchor" id="a212c9a2d54b4526ee13b7527fc670696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_string.html">NSString</a> *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(uint16_t)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to the given host and port with an optional timeout.</p>
<p>This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface. </p>

</div>
</div>
<a class="anchor" id="a6d7dfcd7967c0e16b86ae64e5579b709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSData *) CRLFData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A few common line separators, for use with the readDataToData:... methods. </p>

</div>
</div>
<a class="anchor" id="a960705de531a20389fb29928d43258c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnect </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p>
<p>If the socket is not already disconnected, an invocation to the socketDidDisconnect:withError: delegate method will be queued onto the delegateQueue asynchronously (behind any previously queued delegate methods). In other words, the disconnected delegate method will be invoked sometime shortly after this method returns.</p>
<p>Please note the recommended way of releasing a <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> instance (e.g. in a dealloc method) [asyncSocket setDelegate:nil]; [asyncSocket disconnect]; [asyncSocket release];</p>
<p>If you plan on disconnecting the socket, and then immediately asking it to connect again, you'll likely want to do so like this: [asyncSocket setDelegate:nil]; [asyncSocket disconnect]; [asyncSocket setDelegate:self]; [asyncSocket connect...]; </p>

</div>
</div>
<a class="anchor" id="a9c49760a3286a595f3cdc0702733baed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterReading </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects after all pending reads have completed. After calling this, the read and write methods will do nothing. The socket will disconnect even if there are still pending writes. </p>

</div>
</div>
<a class="anchor" id="a31e39568995cdc85c4feb5a76c645d5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterReadingAndWriting </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects after all pending reads and writes have completed. After calling this, the read and write methods will do nothing. </p>

</div>
</div>
<a class="anchor" id="a40c9570c2e696d6c48347024fa1f8b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterWriting </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects after all pending writes have completed. After calling this, the read and write methods will do nothing. The socket will disconnect even if there are still pending reads. </p>

</div>
</div>
<a class="anchor" id="ad25cbed4327e1a30c369f5367af185f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_string.html">NSString</a> *) hostFromAddress: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>address</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracting host and port information from raw address data. </p>

</div>
</div>
<a class="anchor" id="a4213bb26f5207ee3f402fe463badc691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) init </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> uses the standard delegate paradigm, but executes all delegate callbacks on a given delegate dispatch queue. This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
<p>You MUST set a delegate AND delegate dispatch queue before attempting to use the socket, or you will get an error.</p>
<p>The socket queue is optional. If you pass NULL, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically create it's own socket queue. If you choose to provide a socket queue, the socket queue must not be a concurrent queue. If you choose to provide a socket queue, and the socket queue has a configured target queue, then please see the discussion for the method markSocketQueueTargetQueue.</p>
<p>The delegate queue and socket queue can optionally be the same. </p>

</div>
</div>
<a class="anchor" id="a72a57ce3f39762161947846bbe03a621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isDisconnected </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the socket is disconnected or connected.</p>
<p>A disconnected socket may be recycled. That is, it can used again for connecting or listening.</p>
<p>If a socket is in the process of connecting, it may be neither disconnected nor connected. </p>

</div>
</div>
<a class="anchor" id="a7f1734034c9aa5b62cfeb69f203729e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the socket is IPv4 or IPv6. An accepting socket may be both. </p>

</div>
</div>
<a class="anchor" id="a9fd367a3576e58665df01f6a376621eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4Enabled </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, both IPv4 and IPv6 are enabled.</p>
<p>For accepting incoming connections, this means <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> automatically supports both protocols, and can simulataneously accept incoming connections on either protocol.</p>
<p>For outgoing connections, this means <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> can connect to remote hosts running either protocol. If a DNS lookup returns only IPv4 results, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically use IPv4. If a DNS lookup returns only IPv6 results, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically use IPv6. If a DNS lookup returns both IPv4 and IPv6 results, the preferred protocol will be chosen. By default, the preferred protocol is IPv4, but may be configured as desired. </p>

</div>
</div>
<a class="anchor" id="ac03a5b3ccb5aee5f881792926571db0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isSecure </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not the socket has been secured via SSL/TLS.</p>
<p>See also the startTLS method. </p>

</div>
</div>
<a class="anchor" id="a839e97a5f8fe5f01900dcb41259a535c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markSocketQueueTargetQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>socketNewTargetQueue</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> maintains thread safety by using an internal serial dispatch_queue. In most cases, the instance creates this queue itself. However, to allow for maximum flexibility, the internal queue may be passed in the init method. This allows for some advanced options such as controlling socket priority via target queues. However, when one begins to use target queues like this, they open the door to some specific deadlock issues.</p>
<p>For example, imagine there are 2 queues: dispatch_queue_t socketQueue; dispatch_queue_t socketTargetQueue;</p>
<p>If you do this (pseudo-code): socketQueue.targetQueue = socketTargetQueue;</p>
<p>Then all socketQueue operations will actually get run on the given socketTargetQueue. This is fine and works great in most situations. But if you run code directly from within the socketTargetQueue that accesses the socket, you could potentially get deadlock. Imagine the following code:</p>
<ul>
<li><p class="startli">(BOOL)socketHasSomething { __block BOOL result = NO; dispatch_block_t block = ^{ result = [self someInternalMethodToBeRunOnlyOnSocketQueue]; } if (is_executing_on_queue(socketQueue)) block(); else dispatch_sync(socketQueue, block);</p>
<p class="startli">return result; }</p>
</li>
</ul>
<p>What happens if you call this method from the socketTargetQueue? The result is deadlock. This is because the GCD API offers no mechanism to discover a queue's targetQueue. Thus we have no idea if our socketQueue is configured with a targetQueue. If we had this information, we could easily avoid deadlock. But, since these API's are missing or unfeasible, you'll have to explicitly set it.</p>
<p>IF you pass a socketQueue via the init method, AND you've configured the passed socketQueue with a targetQueue, THEN you should pass the end queue in the target hierarchy.</p>
<p>For example, consider the following queue hierarchy: socketQueue -&gt; ipQueue -&gt; moduleQueue</p>
<p>This example demonstrates priority shaping within some server. All incoming client connections from the same IP address are executed on the same target queue. And all connections for a particular module are executed on the same target queue. Thus, the priority of all networking for the entire module can be changed on the fly. Additionally, networking traffic from a single IP cannot monopolize the module.</p>
<p>Here's how you would accomplish something like that:</p>
<ul>
<li><p class="startli">(dispatch_queue_t)newSocketQueueForConnectionFromAddress:(NSData *)address onSocket:(GCDAsyncSocket *)sock { dispatch_queue_t socketQueue = dispatch_queue_create("", NULL); dispatch_queue_t ipQueue = [self ipQueueForAddress:address];</p>
<p class="startli">dispatch_set_target_queue(socketQueue, ipQueue); dispatch_set_target_queue(iqQueue, moduleQueue);</p>
<p class="startli">return socketQueue; }</p>
</li>
<li>(void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(GCDAsyncSocket *)newSocket { [clientConnections addObject:newSocket]; [newSocket markSocketQueueTargetQueue:moduleQueue]; }</li>
</ul>
<p>Note: This workaround is ONLY needed if you intend to execute code directly on the ipQueue or moduleQueue. This is often NOT the case, as such queues are used solely for execution shaping.</p>
<p>See header file for big discussion of this method. </p>

</div>
</div>
<a class="anchor" id="a0f9e5a401b98234ed1522174f1ef5d33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) performBlock: </td>
          <td></td>
          <td class="paramtype">(dispatch_block_t)&#160;</td>
          <td class="paramname"><em>block</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It's not thread-safe to access certain variables from outside the socket's internal queue.</p>
<p>For example, the socket file descriptor. File descriptors are simply integers which reference an index in the per-process file table. However, when one requests a new file descriptor (by opening a file or socket), the file descriptor returned is guaranteed to be the lowest numbered unused descriptor. So if we're not careful, the following could be possible:</p>
<ul>
<li>Thread A invokes a method which returns the socket's file descriptor.</li>
<li>The socket is closed via the socket's internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket's FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>
<p>In addition to this, other variables are not actually objects, and thus cannot be retained/released or even autoreleased. An example is the sslContext, of type SSLContextRef, which is actually a malloc'd struct.</p>
<p>Although there are internal variables that make it difficult to maintain thread-safety, it is important to provide access to these variables to ensure this class can be used in a wide array of environments. This method helps to accomplish this by invoking the current block on the socket's internal queue. The methods below can be invoked from within the block to access those generally thread-unsafe internal variables in a thread-safe manner. The given block will be invoked synchronously on the socket's internal queue.</p>
<p>If you save references to any protected variables and use them outside the block, you do so at your own peril.</p>
<p>See header file for big discussion of this method. </p>

</div>
</div>
<a class="anchor" id="afdb958711cc3c0089b4a89f7dfed45a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (float) progressOfReadReturningTag: </td>
          <td></td>
          <td class="paramtype">(long *)&#160;</td>
          <td class="paramname"><em>tagPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">bytesDone:</td>
          <td></td>
          <td class="paramtype">(NSUInteger *)&#160;</td>
          <td class="paramname"><em>donePtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">total:</td>
          <td></td>
          <td class="paramtype">(NSUInteger *)&#160;</td>
          <td class="paramname"><em>totalPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check). The parameters "tag", "done" and "total" will be filled in if they aren't NULL. </p>

</div>
</div>
<a class="anchor" id="a5c5daeaa738324a501b418d7cc283a35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (float) progressOfWriteReturningTag: </td>
          <td></td>
          <td class="paramtype">(long *)&#160;</td>
          <td class="paramname"><em>tagPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">bytesDone:</td>
          <td></td>
          <td class="paramtype">(NSUInteger *)&#160;</td>
          <td class="paramname"><em>donePtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">total:</td>
          <td></td>
          <td class="paramtype">(NSUInteger *)&#160;</td>
          <td class="paramname"><em>totalPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check). The parameters "tag", "done" and "total" will be filled in if they aren't NULL. </p>

</div>
</div>
<a class="anchor" id="a2a8c215b2b1baee60b831081a5e302ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If maxLength is zero, no length restriction is enforced. Otherwise if maxLength bytes are read without completing the read, it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError. The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>
<p>If you pass a maxLength parameter that is less than the length of the data (separator) parameter, the method will do nothing (except maybe print a warning), and the delegate will not be called. If the bufferOffset is greater than the length of the given buffer, the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while the socket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer via the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. If you're developing your own custom protocol, be sure your separator can not occur naturally as part of the data between separators. For example, imagine you want to send several small documents over a socket. Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents. In this particular example, it would be better to use a protocol similar to HTTP with a header that includes the length of the document. Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>
<p>The given data (separator) parameter should be immutable. For performance reasons, the socket will retain it, not copy it. So if it is immutable, don't modify it while the socket is using it. </p>

</div>
</div>
<a class="anchor" id="a8782b6bf0862529a8efad865b20eb55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while the socket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer via the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. If you're developing your own custom protocol, be sure your separator can not occur naturally as part of the data between separators. For example, imagine you want to send several small documents over a socket. Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents. In this particular example, it would be better to use a protocol similar to HTTP with a header that includes the length of the document. Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>
<p>The given data (separator) parameter should be immutable. For performance reasons, the socket will retain it, not copy it. So if it is immutable, don't modify it while the socket is using it. </p>

</div>
</div>
<a class="anchor" id="abfb0d880d5853402309d80151c19ef85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If maxLength is zero, no length restriction is enforced. Otherwise if maxLength bytes are read without completing the read, it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError. The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>
<p>If you pass nil or zero-length data as the "data" parameter, the method will do nothing (except maybe print a warning), and the delegate will not be called. If you pass a maxLength parameter that is less than the length of the data parameter, the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. If you're developing your own custom protocol, be sure your separator can not occur naturally as part of the data between separators. For example, imagine you want to send several small documents over a socket. Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents. In this particular example, it would be better to use a protocol similar to HTTP with a header that includes the length of the document. Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>
<p>The given data (separator) parameter should be immutable. For performance reasons, the socket will retain it, not copy it. So if it is immutable, don't modify it while the socket is using it. </p>

</div>
</div>
<a class="anchor" id="a3a92e46de7766b3ac649f3d68d370599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If you pass nil or zero-length data as the "data" parameter, the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. If you're developing your own custom protocol, be sure your separator can not occur naturally as part of the data between separators. For example, imagine you want to send several small documents over a socket. Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents. In this particular example, it would be better to use a protocol similar to HTTP with a header that includes the length of the document. Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>
<p>The given data (separator) parameter should be immutable. For performance reasons, the socket will retain it, not copy it. So if it is immutable, don't modify it while the socket is using it. </p>

</div>
</div>
<a class="anchor" id="a7f742375bde66d11c43a478835c04805"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the given number of bytes. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If the length is 0, this method does nothing and the delegate is not called. If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer via the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO]. </p>

</div>
</div>
<a class="anchor" id="a2acf5d5f2c006ea0e14a97b8802bdf7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the given number of bytes.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If the length is 0, this method does nothing and the delegate is not called. </p>

</div>
</div>
<a class="anchor" id="a9ec74c83f6f87dfd8980c98deae38640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the first available bytes that become available on the socket. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed. A maximum of length bytes will be read.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you. If maxLength is zero, no length restriction is enforced.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while the socket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer via the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO]. </p>

</div>
</div>
<a class="anchor" id="a289b8c694675c219c9726385c90e8068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the first available bytes that become available on the socket. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, the socket will create a buffer for you.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while the socket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer via the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO]. </p>

</div>
</div>
<a class="anchor" id="a58e63ca19338d5e052ad36e2e64ec585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the first available bytes that become available on the socket.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. </p>

</div>
</div>
<a class="anchor" id="adc2fecde2f4d460a7e8d010d9cf01300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setAutoDisconnectOnClosedReadStream: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See header file for big discussion of this method. </p>

</div>
</div>
<a class="anchor" id="a2b9c119ffa6ff18321572f26a759b9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socket4FD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Questions? Have you read the header file? </p>

</div>
</div>
<a class="anchor" id="ad6120d297c599aff1e50bd2ce917e3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socket6FD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Questions? Have you read the header file? </p>

</div>
</div>
<a class="anchor" id="ad7cd01612683e0994e7ef2fadf77952e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socketFD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These methods are only available from within the context of a performBlock: invocation. See the documentation for the performBlock: method above.</p>
<p>Provides access to the socket's file descriptor(s). If the socket is a server socket (is accepting incoming connections), it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6.</p>
<p>Questions? Have you read the header file? </p>

</div>
</div>
<a class="anchor" id="a09f53a1bc824259a55ff249183111beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (SSLContextRef) sslContext </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is only available from within the context of a performBlock: invocation. See the documentation for the performBlock: method above.</p>
<p>Provides access to the socket's SSLContext, if SSL/TLS has been started on the socket. </p>

</div>
</div>
<a class="anchor" id="aec4d670add3f78c669277990d7b48056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) startTLS: </td>
          <td></td>
          <td class="paramtype">(NSDictionary *)&#160;</td>
          <td class="paramname"><em>tlsSettings</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Secures the connection using SSL/TLS.</p>
<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing the upgrade to TLS at the same time, without having to wait for the write to finish. Any reads or writes scheduled after this method is called will occur over the secured connection.</p>
<p>The possible keys and values for the TLS settings are well documented. Standard keys are:</p>
<ul>
<li>kCFStreamSSLLevel</li>
<li>kCFStreamSSLAllowsExpiredCertificates</li>
<li>kCFStreamSSLAllowsExpiredRoots</li>
<li>kCFStreamSSLAllowsAnyRoot</li>
<li>kCFStreamSSLValidatesCertificateChain</li>
<li>kCFStreamSSLPeerName</li>
<li>kCFStreamSSLCertificates</li>
<li>kCFStreamSSLIsServer</li>
</ul>
<p>If SecureTransport is available on iOS:</p>
<ul>
<li>GCDAsyncSocketSSLCipherSuites</li>
<li>GCDAsyncSocketSSLProtocolVersionMin</li>
<li>GCDAsyncSocketSSLProtocolVersionMax</li>
</ul>
<p>If SecureTransport is available on Mac OS X:</p>
<ul>
<li>GCDAsyncSocketSSLCipherSuites</li>
<li>GCDAsyncSocketSSLDiffieHellmanParameters;</li>
</ul>
<p>Please refer to Apple's documentation for associated values, as well as other possible keys.</p>
<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>
<p>The default settings will check to make sure the remote party's certificate is signed by a trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired. However it will not verify the name on the certificate unless you give it a name to verify against via the kCFStreamSSLPeerName key. The security implications of this are important to understand. Imagine you are attempting to create a secure connection to MySecureServer.com, but your socket gets directed to MaliciousServer.com because of a hacked DNS server. If you simply use the default settings, and MaliciousServer.com has a valid certificate, the default settings will not detect any problems since the certificate is valid. To properly secure your connection in this particular scenario you should set the kCFStreamSSLPeerName property to "MySecureServer.com". If you do not know the peer name of the remote host in advance (for example, you're not sure if it will be "domain.com" or "www.domain.com"), then you can use the default settings to validate the certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured. The X509Certificate class is part of the CocoaAsyncSocket open source project. </p>

</div>
</div>
<a class="anchor" id="a76712c0f929cd79210da79ba74e7d1f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) unmarkSocketQueueTargetQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>socketOldTargetQueue</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See header file for big discussion of this method. </p>

</div>
</div>
<a class="anchor" id="ab46069d6ffbcb6a0bb1eae5aaaafe94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) userData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User data allows you to associate arbitrary information with the socket. This data is not used internally by socket in any way. </p>

</div>
</div>
<a class="anchor" id="a7f85c2e3c19bbe013c180b4668a28fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) writeData: </td>
          <td></td>
          <td class="paramtype">(NSData *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to the socket, and calls the delegate when finished.</p>
<p>If you pass in nil or zero-length data, this method does nothing and the delegate will not be called. If the timeout value is negative, the write operation will not use a timeout.</p>
<p>Thread-Safety Note: If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while the socket is writing it. In other words, it's not safe to alter the data until after the delegate method socket:didWriteDataWithTag: is invoked signifying that this particular write operation has completed. This is due to the fact that <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> does NOT copy the data. It simply retains it. This is for performance reasons. Often times, if NSMutableData is passed, it is because a request/response was built up in memory. Copying this data adds an unwanted/unneeded overhead. If you need to write data from an immutable buffer, and you need to alter the buffer before the socket completes writing the bytes (which is NOT immediately after this method returns, but rather at a later time when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_g_c_d_async_socket_8h_source.html">GCDAsyncSocket.h</a></li>
<li>GCDAsyncSocket.m</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 3 2013 20:57:26 for Mobile Clinic by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
