<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mobile Clinic: GCDAsyncReadPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="clinicLogo.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mobile Clinic
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Senior Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">GCDAsyncReadPacket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for GCDAsyncReadPacket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_read_packet__inherit__graph.png" border="0" usemap="#_g_c_d_async_read_packet_inherit__map" alt="Inheritance graph"/></div>
<map name="_g_c_d_async_read_packet_inherit__map" id="_g_c_d_async_read_packet_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for GCDAsyncReadPacket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_read_packet__coll__graph.png" border="0" usemap="#_g_c_d_async_read_packet_coll__map" alt="Collaboration graph"/></div>
<map name="_g_c_d_async_read_packet_coll__map" id="_g_c_d_async_read_packet_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4436fce4ebeab5bd3c95fc02fa1a69c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4436fce4ebeab5bd3c95fc02fa1a69c3"></a>
(id)&#160;</td><td class="memItemRight" valign="bottom">- <b>initWithData:startOffset:maxLength:timeout:readLength:terminator:tag:</b></td></tr>
<tr class="memitem:ade0dcd4770cf0b0fdbf0ef1079332b3f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#ade0dcd4770cf0b0fdbf0ef1079332b3f">ensureCapacityForAdditionalDataOfLength:</a></td></tr>
<tr class="memitem:acb91f09ee91aa6a39ad951adfb4d3095"><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#acb91f09ee91aa6a39ad951adfb4d3095">optimalReadLengthWithDefault:shouldPreBuffer:</a></td></tr>
<tr class="memitem:aa3f07c7dcd5a963718d5e059a2779308"><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#aa3f07c7dcd5a963718d5e059a2779308">readLengthForNonTermWithHint:</a></td></tr>
<tr class="memitem:afed7fbed6868daffad1669d412591eb9"><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#afed7fbed6868daffad1669d412591eb9">readLengthForTermWithHint:shouldPreBuffer:</a></td></tr>
<tr class="memitem:adf44fdde3ce97063e5bdcbc9a3011f32"><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#adf44fdde3ce97063e5bdcbc9a3011f32">readLengthForTermWithPreBuffer:found:</a></td></tr>
<tr class="memitem:a6fbcbaa0f70464faafa3200e69eca2b0"><td class="memItemLeft" align="right" valign="top">(NSInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#a6fbcbaa0f70464faafa3200e69eca2b0">searchForTermAfterPreBuffering:</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a7ab0bf89e1cb8317d120c9c44ab611f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ab0bf89e1cb8317d120c9c44ab611f0"></a>
NSMutableData *&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr class="memitem:aea3d7b4fd77937133adf696035109a21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea3d7b4fd77937133adf696035109a21"></a>
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>startOffset</b></td></tr>
<tr class="memitem:a19e34e7d78011c64d9320be5be7f7080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19e34e7d78011c64d9320be5be7f7080"></a>
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>bytesDone</b></td></tr>
<tr class="memitem:a786b76fb3ef6c4d817c06dea78bed863"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a786b76fb3ef6c4d817c06dea78bed863"></a>
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>maxLength</b></td></tr>
<tr class="memitem:a39233eb85b4cbae04411577510e7c5e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39233eb85b4cbae04411577510e7c5e6"></a>
NSTimeInterval&#160;</td><td class="memItemRight" valign="bottom"><b>timeout</b></td></tr>
<tr class="memitem:a8527367b5c530994b2c522afbca02ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8527367b5c530994b2c522afbca02ae7"></a>
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>readLength</b></td></tr>
<tr class="memitem:ac09dba8aa168ea0ea2797060e554412e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac09dba8aa168ea0ea2797060e554412e"></a>
NSData *&#160;</td><td class="memItemRight" valign="bottom"><b>term</b></td></tr>
<tr class="memitem:accec9974ec2def72cad1543d9a76d429"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accec9974ec2def72cad1543d9a76d429"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>bufferOwner</b></td></tr>
<tr class="memitem:a905e3b38997be141c88b5922210b0480"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905e3b38997be141c88b5922210b0480"></a>
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>originalBufferLength</b></td></tr>
<tr class="memitem:ae10c29173f0af40507d7e787905c7130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae10c29173f0af40507d7e787905c7130"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>tag</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a> encompasses the instructions for any given read. The content of a read packet allows the code to determine if we're:</p>
<ul>
<li>reading to a certain length</li>
<li>reading to a certain separator</li>
<li>or simply reading the first chunk of available data </li>
</ul>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ade0dcd4770cf0b0fdbf0ef1079332b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) ensureCapacityForAdditionalDataOfLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>bytesToRead</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the length of the buffer (if needed) to ensure a read of the given size will fit. </p>

</div>
</div>
<a class="anchor" id="acb91f09ee91aa6a39ad951adfb4d3095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) optimalReadLengthWithDefault: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>defaultValue</em></td>
        </tr>
        <tr>
          <td class="paramkey">shouldPreBuffer:</td>
          <td></td>
          <td class="paramtype">(BOOL *)&#160;</td>
          <td class="paramname"><em>shouldPreBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used when we do NOT know how much data is available to be read from the socket. This method returns the default value unless it exceeds the specified readLength or maxLength.</p>
<p>Furthermore, the shouldPreBuffer decision is based upon the packet type, and whether the returned value would fit in the current buffer without requiring a resize of the buffer. </p>

</div>
</div>
<a class="anchor" id="aa3f07c7dcd5a963718d5e059a2779308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) readLengthForNonTermWithHint: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>bytesAvailable</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For read packets without a set terminator, returns the amount of data that can be read without exceeding the readLength or maxLength.</p>
<p>The given parameter indicates the number of bytes estimated to be available on the socket, which is taken into consideration during the calculation.</p>
<p>The given hint MUST be greater than zero. </p>

</div>
</div>
<a class="anchor" id="afed7fbed6868daffad1669d412591eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) readLengthForTermWithHint: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>bytesAvailable</em></td>
        </tr>
        <tr>
          <td class="paramkey">shouldPreBuffer:</td>
          <td></td>
          <td class="paramtype">(BOOL *)&#160;</td>
          <td class="paramname"><em>shouldPreBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For read packets with a set terminator, returns the amount of data that can be read without exceeding the maxLength.</p>
<p>The given parameter indicates the number of bytes estimated to be available on the socket, which is taken into consideration during the calculation.</p>
<p>To optimize memory allocations, mem copies, and mem moves the shouldPreBuffer boolean value will indicate if the data should be read into a prebuffer first, or if the data can be read directly into the read packet's buffer. </p>

</div>
</div>
<a class="anchor" id="adf44fdde3ce97063e5bdcbc9a3011f32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) readLengthForTermWithPreBuffer: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_g_c_d_async_socket_pre_buffer.html">GCDAsyncSocketPreBuffer</a> *)&#160;</td>
          <td class="paramname"><em>preBuffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">found:</td>
          <td></td>
          <td class="paramtype">(BOOL *)&#160;</td>
          <td class="paramname"><em>foundPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For read packets with a set terminator, returns the amount of data that can be read from the given preBuffer, without going over a terminator or the maxLength.</p>
<p>It is assumed the terminator has not already been read. </p>

</div>
</div>
<a class="anchor" id="a6fbcbaa0f70464faafa3200e69eca2b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSInteger) searchForTermAfterPreBuffering: </td>
          <td></td>
          <td class="paramtype">(ssize_t)&#160;</td>
          <td class="paramname"><em>numBytes</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For read packets with a set terminator, scans the packet buffer for the term. It is assumed the terminator had not been fully read prior to the new bytes.</p>
<p>If the term is found, the number of excess bytes after the term are returned. If the term is not found, this method will return -1.</p>
<p>Note: A return value of zero means the term was found at the very end.</p>
<p>Prerequisites: The given number of bytes have been added to the end of our buffer. Our bytesDone variable has NOT been changed due to the prebuffered bytes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>GCDAsyncSocket.m</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 3 2013 20:57:26 for Mobile Clinic by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
